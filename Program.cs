#region License
/*
JFDI the .Net Job Framework (http://jfdi.sourceforge.net)
Copyright (C) 2006  Steven Ward (steve.ward.uk@gmail.com)

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
*/
#endregion

using System;
using System.IO;
using System.Reflection;
using System.Xml;

namespace JFDI.Utils.XSDExtractor {
  
  /// <summary>
  /// Responsible for converting any config section class
  /// into an xsd which can then be used to create a 
  /// valid config section 
  /// </summary>
  class Program {

    string rootElementName = string.Empty;
    bool silent = false;
    string[] args;
    string className = string.Empty;
    FileInfo assemblyInfo = null;
    
    static void Main(string[] args) {
      new Program().Run(args);
    }

    /// <summary>
    /// Starts the process of 
    /// </summary>
    /// <param name="args"></param>
    public void Run(string[] args) {

      int converted = 0;
      
      this.args = FixArgs(args);
      ParseSwitches();
      ShowWelcomeMessage();
      string[] assemblies = DiscoverAssemblies();

      ConfigurationSectionFinderCoOrdinator coord = new ConfigurationSectionFinderCoOrdinator(assemblies);
      Type[] types = coord.GetConfigSectionTypes(className);
      foreach (Type configType in types) {

        //  generate the schema
        XSDGenerator generator = new XSDGenerator(configType);
        string rootElement = string.IsNullOrEmpty(rootElementName) ? configType.ToString() : rootElementName;
        generator.GenerateXSD(rootElement);

        //  work out what we're going to call the xsd
        FileInfo fInfo = new FileInfo(configType.Assembly.Location);
        string fileName = fInfo.DirectoryName + @"\" + rootElement + ".xsd";

        //  warn about the file replacement
        if (!silent && File.Exists(fileName)) {
          Console.WriteLine();
          Console.Write(string.Format("{0} exists, replace (y/n)?", fileName));
          if (Console.ReadKey().Key != ConsoleKey.Y)
            continue;
        } else {
          Console.WriteLine(string.Format("Writing: {0}", fileName));
        }

        using (MemoryStream memoryStream = new MemoryStream()) {

          converted++;
          generator.Schema.Write(memoryStream);

          using (MemoryStream commentedMemoryStream = AddXsdComment(memoryStream, configType)) {

            using (FileStream fs = new FileStream(fileName, FileMode.Create, FileAccess.Write, FileShare.None)) {

              fs.Write(commentedMemoryStream.ToArray(), 0, (int)commentedMemoryStream.Length);

            }
          }

        }

      }

      //  write out what we did
      Console.WriteLine();
      Console.WriteLine(string.Format("# of assemblies inspected : {0}", assemblies.Length));
      Console.WriteLine(string.Format("# of types inspected      : {0}", types.Length));
      Console.WriteLine(string.Format("# of Xsd's created        : {0}", converted));
      
    }

    /// <summary>
    /// Adds a standard comment section to the beginning of the Xsd file
    /// so that anybody reading the file can tell where it came from etc
    /// </summary>
    private MemoryStream AddXsdComment(MemoryStream memoryStream, Type type) {

      memoryStream.Position = 0;
      XmlDocument doc = new XmlDocument();
      doc.Load(memoryStream);

      string commentStr = Environment.NewLine + Environment.NewLine;
      commentStr += "This file is auto-generated by XSDExtractor (v" + Assembly.GetExecutingAssembly().GetName().Version.ToString(3) + "), a command-line utility which forms part of the .Net Job Framework (http://jfdi.sourceforge.net) written in C# 2.0 by Steve Ward." + Environment.NewLine;
      commentStr += "XSDExtractor is available at http://www.codeproject.com/useritems/extractxsdfromconfigsect.asp." + Environment.NewLine;
      commentStr += "The utility and source code are free to use and are released under the GNU Lesser General Public License (http://www.gnu.org/licenses/lgpl.txt)." + Environment.NewLine;
      commentStr += "They are both released with the usual yada-yada about limitations of responsibility when using it etc. Please read the GNU Lesser General Public License for full details." + Environment.NewLine;
      commentStr += "If you've got any questions or requests for the utility I may be contacted at steve.ward.uk@gmail.com." + Environment.NewLine;
      commentStr += Environment.NewLine;
      commentStr += "File created: " + DateTime.UtcNow.ToString() + " UTC" + Environment.NewLine;
      commentStr += "By: " + Environment.UserDomainName + "\\" + Environment.UserName + Environment.NewLine;
      commentStr += "Machine: " + Environment.MachineName + Environment.NewLine;
      commentStr += "Command line: " + Environment.CommandLine + Environment.NewLine;
      commentStr += "ConfigurationSection: " + type.AssemblyQualifiedName;
      commentStr += Environment.NewLine + Environment.NewLine;
      
      XmlComment comment = doc.CreateComment(commentStr);
      doc.InsertBefore(comment, doc.DocumentElement);

      MemoryStream retVal = new MemoryStream();
      doc.Save(retVal);
      retVal.Position = 0;

      return retVal;

    }

    /// <summary>
    /// Based on the command line options, this method
    /// finds all the assemblies that we should work on
    /// </summary>
    /// <returns></returns>
    private string[] DiscoverAssemblies() {

      //  no assembly info given so get all of them!
      if(assemblyInfo == null) {

        ConsoleKeyInfo key = new ConsoleKeyInfo('y', ConsoleKey.Y, false, false, false);
        if (!silent) {
          Console.WriteLine();
          Console.Write(string.Format("Generate Xml Schema's for all assemblies in current / sub directories (y/n)?"));
          Console.WriteLine();
          key = Console.ReadKey();
        }
        
        if (key.Key == ConsoleKey.Y) {

          string[] dllAssemblies = Directory.GetFiles(Directory.GetCurrentDirectory(), "*.dll", SearchOption.AllDirectories);
          string[] exeAssemblies = Directory.GetFiles(Directory.GetCurrentDirectory(), "*.exe", SearchOption.AllDirectories);

          string[] assemblies = new string[dllAssemblies.Length + exeAssemblies.Length];
          Array.Copy(dllAssemblies, assemblies, dllAssemblies.Length);
          Array.Copy(exeAssemblies, 0, assemblies, dllAssemblies.Length, exeAssemblies.Length);

          return assemblies;

        }
        else {
          ShowUsage();
          Environment.Exit(-1);
          return null;

        }
          
      } else {

        //  must be a dir
        if (!assemblyInfo.Exists) {
          
          string[] dllAssemblies = Directory.GetFiles(assemblyInfo.Directory.FullName, "*.dll", SearchOption.AllDirectories);
          string[] exeAssemblies = Directory.GetFiles(assemblyInfo.Directory.FullName, "*.exe", SearchOption.AllDirectories);

          string[] assemblies = new string[dllAssemblies.Length + exeAssemblies.Length];
          Array.Copy(dllAssemblies, assemblies, dllAssemblies.Length);
          Array.Copy(exeAssemblies, 0, assemblies, dllAssemblies.Length, exeAssemblies.Length);

          return assemblies;          
          
        } else {
        
          return new string[] { assemblyInfo.FullName };
          
        }
        
      }
      
    }

    /// <summary>
    /// Converts the switches so that the argument and the switch are 
    /// in the same array element
    /// </summary>
    private string[] FixArgs(string[] args) {
      
      if(args.Length % 2 != 0) {
        ShowUsage();
        Environment.Exit(-1);
      }
      
      string[] retVal = new string[args.Length / 2];
      for (int i = 0; i < args.Length;i++) {
        retVal[i - (i / 2) - (i % 2)] += args[i] + " ";
      }
      
      return retVal;
      
    }
    
    /// <summary>
    /// Reads the command line switches
    /// </summary>
    private void ParseSwitches() {
      
      foreach (string s in args) {

        switch (s.Substring(1, 1).ToLower()) {
          case "r":
            rootElementName = s.Substring(2).Trim();
            break;
          case "s":
            silent = Boolean.Parse(s.Substring(2).Trim());
            break;
          case "c":
            className = s.Substring(2).Trim();
            break;
          case "a":
            assemblyInfo = new FileInfo(s.Substring(2, s.Length - 2).Trim());
            if (!assemblyInfo.Exists && !assemblyInfo.Directory.Exists) {
              Console.WriteLine(string.Format("Could not find assembly specified: {0}", s.Substring(2).Trim()));
              Environment.Exit(-1);
            }
            break;
          default:
            ShowUsage();
            Environment.Exit(-1);
            break;
        
        }
        
      }
      
    }

    /// <summary>
    /// Standard message given when the program starts
    /// </summary>
    private void ShowWelcomeMessage() {

      Console.WriteLine();
      Console.WriteLine(string.Format("XSDExtractor v{0} (c) 2006 Steve Ward (steve.ward.uk@gmail.com)", Assembly.GetExecutingAssembly().GetName().Version.ToString(3)));
      Console.WriteLine("Released under the GNU Lesser General Public License");
      Console.WriteLine();
      Console.WriteLine("XSDExtractor will attempt to extract an Xml Schema (XSD) from a compiled\nConfigurationSection type. It does this by searching for\nConfigurationPropertyAttribute and ConfigurationCollectionAttribute attributes.");
      Console.WriteLine();
      Console.WriteLine("Warning: This program will give inconsistent results if the type being \nconverted has used the programmatic way of creating ConfigurationSection \nsub-classes as opposed to the declaritive model using attributes.");
      Console.WriteLine(new string('-', 80));

    }
    
    /// <summary>
    /// Message which describes how to use the program
    /// </summary>
    private void ShowUsage() {

      Console.WriteLine();
      Console.WriteLine("XSDExtractor [/R root] [/C class] [/A assembly] [/S bool]");
      Console.WriteLine("");
      Console.WriteLine("    /R\t\tName of the Xsd root element");
      Console.WriteLine("    root\tIf ommited then the type name of the configurationsection \n\t\tis used instead.");
      Console.WriteLine("");
      Console.WriteLine("    /C\t\tName of the class which should be converted to an Xsd. If \n\t\tommited then all classes are examined.");
      Console.WriteLine("    class\tFull name (including namespace) of class");
      Console.WriteLine("");
      Console.WriteLine("    /A\t\tName of the assembly which should be examined. If ommited then \n\t\tall assemblies in the current directory are examined.");
      Console.WriteLine("    assembly\tName of the assembly to inspect (path information is optional)");
      Console.WriteLine("");
      Console.WriteLine("    /S\t\tSilence.");
      Console.WriteLine("    bool\tIf true then the user is not prompted at any point.");
      
    }

  }

}